// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "../node_modules/rescript/lib/es6/curry.js";
import * as Belt_Id from "../node_modules/rescript/lib/es6/belt_Id.js";
import * as Belt_Set from "../node_modules/rescript/lib/es6/belt_Set.js";
import * as Caml_obj from "../node_modules/rescript/lib/es6/caml_obj.js";
import * as Belt_List from "../node_modules/rescript/lib/es6/belt_List.js";
import * as Belt_Array from "../node_modules/rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "../node_modules/rescript/lib/es6/belt_Option.js";

var cmp = Caml_obj.caml_compare;

var CmpDigit = Belt_Id.MakeComparable({
      cmp: cmp
    });

var unarySet = Belt_Set.fromArray([0], CmpDigit);

var binarySet = Belt_Set.add(unarySet, 1);

var ternarySet = Belt_Set.add(binarySet, 2);

var quaternarySet = Belt_Set.add(ternarySet, 3);

var quinarySet = Belt_Set.add(quaternarySet, 4);

var senarySet = Belt_Set.add(quinarySet, 5);

var septenarySet = Belt_Set.add(senarySet, 6);

var octalSet = Belt_Set.add(septenarySet, 7);

var nonarySet = Belt_Set.add(octalSet, 8);

var decimalSet = Belt_Set.add(nonarySet, 9);

var undecimalSet = Belt_Set.add(decimalSet, "a");

var duodecimalSet = Belt_Set.add(undecimalSet, "b");

var tridecimalSet = Belt_Set.add(duodecimalSet, "c");

var tetradecimalSet = Belt_Set.add(tridecimalSet, "d");

var pentadecimalSet = Belt_Set.add(tetradecimalSet, "e");

var hexadecimalSet = Belt_Set.add(pentadecimalSet, "f");

function pred(digit) {
  if (digit === 1) {
    return 0;
  } else if (digit === 2) {
    return 1;
  } else if (digit === 3) {
    return 2;
  } else if (digit === 4) {
    return 3;
  } else if (digit === 5) {
    return 4;
  } else if (digit === 6) {
    return 5;
  } else if (digit === 7) {
    return 6;
  } else if (digit === 8) {
    return 7;
  } else if (digit === 9) {
    return 8;
  } else if (digit === "a") {
    return 9;
  } else if (digit === "b") {
    return "a";
  } else if (digit === "c") {
    return "b";
  } else if (digit === "d") {
    return "c";
  } else if (digit === "e") {
    return "d";
  } else if (digit === "f") {
    return "e";
  } else {
    return ;
  }
}

function succ(digit) {
  if (digit === 1) {
    return 2;
  } else if (digit === 2) {
    return 3;
  } else if (digit === 3) {
    return 4;
  } else if (digit === 4) {
    return 5;
  } else if (digit === 5) {
    return 6;
  } else if (digit === 6) {
    return 7;
  } else if (digit === 7) {
    return 8;
  } else if (digit === 8) {
    return 9;
  } else if (digit === 9) {
    return "a";
  } else if (digit === "a") {
    return "b";
  } else if (digit === "b") {
    return "c";
  } else if (digit === "c") {
    return "d";
  } else if (digit === "d") {
    return "e";
  } else if (digit === "e") {
    return "f";
  } else if (digit === "f") {
    return ;
  } else {
    return 1;
  }
}

function show(digit) {
  if (digit === 1) {
    return "1";
  } else if (digit === 2) {
    return "2";
  } else if (digit === 3) {
    return "3";
  } else if (digit === 4) {
    return "4";
  } else if (digit === 5) {
    return "5";
  } else if (digit === 6) {
    return "6";
  } else if (digit === 7) {
    return "7";
  } else if (digit === 8) {
    return "8";
  } else if (digit === 9) {
    return "9";
  } else if (digit === "a") {
    return "a";
  } else if (digit === "b") {
    return "b";
  } else if (digit === "c") {
    return "c";
  } else if (digit === "d") {
    return "d";
  } else if (digit === "e") {
    return "e";
  } else if (digit === "f") {
    return "f";
  } else {
    return "0";
  }
}

function fromStr(d_str) {
  var match = d_str.toLowerCase();
  switch (match) {
    case "0" :
        return 0;
    case "1" :
        return 1;
    case "2" :
        return 2;
    case "3" :
        return 3;
    case "4" :
        return 4;
    case "5" :
        return 5;
    case "6" :
        return 6;
    case "7" :
        return 7;
    case "8" :
        return 8;
    case "9" :
        return 9;
    case "a" :
        return "a";
    case "b" :
        return "b";
    case "c" :
        return "c";
    case "d" :
        return "d";
    case "e" :
        return "e";
    case "f" :
        return "f";
    default:
      return ;
  }
}

var fromStrExn = fromStr;

function allBases(digit) {
  if (digit === 1) {
    return Belt_Array.range(1, 2);
  } else if (digit === 2) {
    return Belt_Array.range(1, 3);
  } else if (digit === 3) {
    return Belt_Array.range(1, 4);
  } else if (digit === 4) {
    return Belt_Array.range(1, 5);
  } else if (digit === 5) {
    return Belt_Array.range(1, 6);
  } else if (digit === 6) {
    return Belt_Array.range(1, 7);
  } else if (digit === 7) {
    return Belt_Array.range(1, 8);
  } else if (digit === 8) {
    return Belt_Array.range(1, 9);
  } else if (digit === 9) {
    return Belt_Array.range(1, 10);
  } else if (digit === "a") {
    return Belt_Array.range(1, 11);
  } else if (digit === "b") {
    return Belt_Array.range(1, 12);
  } else if (digit === "c") {
    return Belt_Array.range(1, 13);
  } else if (digit === "d") {
    return Belt_Array.range(1, 14);
  } else if (digit === "e") {
    return Belt_Array.range(1, 15);
  } else if (digit === "f") {
    return Belt_Array.range(1, 16);
  } else {
    return [1];
  }
}

function hasBase(digit, base) {
  switch (base) {
    case 0 :
    case 1 :
        return true;
    case 2 :
        return Belt_Set.has(binarySet, digit);
    case 3 :
        return Belt_Set.has(ternarySet, digit);
    case 4 :
        return Belt_Set.has(quaternarySet, digit);
    case 5 :
        return Belt_Set.has(quinarySet, digit);
    case 6 :
        return Belt_Set.has(senarySet, digit);
    case 7 :
        return Belt_Set.has(septenarySet, digit);
    case 8 :
        return Belt_Set.has(octalSet, digit);
    case 9 :
        return Belt_Set.has(nonarySet, digit);
    case 10 :
        return Belt_Set.has(decimalSet, digit);
    case 11 :
        return Belt_Set.has(undecimalSet, digit);
    case 12 :
        return Belt_Set.has(duodecimalSet, digit);
    case 13 :
        return Belt_Set.has(tridecimalSet, digit);
    case 14 :
        return Belt_Set.has(tetradecimalSet, digit);
    case 15 :
        return Belt_Set.has(pentadecimalSet, digit);
    case 16 :
        return Belt_Set.has(hexadecimalSet, digit);
    default:
      return false;
  }
}

function makeBinary(digit) {
  if (digit === 0) {
    return 0;
  } else if (digit === 1) {
    return 1;
  } else {
    return ;
  }
}

function makeDecimal(digit) {
  if (digit === 0) {
    return 0;
  } else if (digit === 1) {
    return 1;
  } else if (digit === 2) {
    return 2;
  } else if (digit === 3) {
    return 3;
  } else if (digit === 4) {
    return 4;
  } else if (digit === 5) {
    return 5;
  } else if (digit === 6) {
    return 6;
  } else if (digit === 7) {
    return 7;
  } else if (digit === 8) {
    return 8;
  } else if (digit === 9) {
    return 9;
  } else {
    return ;
  }
}

function makeHexadecimal(digit) {
  return digit;
}

function makeBaseListExn(d_lst, fn_toBase) {
  return Belt_List.map(d_lst, (function (d) {
                return Belt_Option.getExn(Curry._1(fn_toBase, d));
              }));
}

function makeBaseList(d_lst, fn_toBase) {
  var base_lst = Belt_List.keepMap(d_lst, Curry.__1(fn_toBase));
  if (Belt_List.length(base_lst) === Belt_List.length(d_lst)) {
    return base_lst;
  }
  
}

function makeBaseArrExn(d_arr, fn_toBase) {
  return Belt_Array.map(d_arr, (function (d) {
                return Belt_Option.getExn(Curry._1(fn_toBase, d));
              }));
}

function makeBaseArr(d_arr, fn_toBase) {
  var base_arr = Belt_Array.keepMap(d_arr, Curry.__1(fn_toBase));
  if (base_arr.length === d_arr.length) {
    return base_arr;
  }
  
}

var Digit = {
  CmpDigit: CmpDigit,
  unarySet: unarySet,
  binarySet: binarySet,
  ternarySet: ternarySet,
  quaternarySet: quaternarySet,
  quinarySet: quinarySet,
  senarySet: senarySet,
  septenarySet: septenarySet,
  octalSet: octalSet,
  nonarySet: nonarySet,
  decimalSet: decimalSet,
  undecimalSet: undecimalSet,
  duodecimalSet: duodecimalSet,
  tridecimalSet: tridecimalSet,
  tetradecimalSet: tetradecimalSet,
  pentadecimalSet: pentadecimalSet,
  hexadecimalSet: hexadecimalSet,
  pred: pred,
  succ: succ,
  show: show,
  fromStr: fromStr,
  fromStrExn: fromStrExn,
  allBases: allBases,
  hasBase: hasBase,
  makeBinary: makeBinary,
  makeDecimal: makeDecimal,
  makeHexadecimal: makeHexadecimal,
  makeBaseListExn: makeBaseListExn,
  makeBaseList: makeBaseList,
  makeBaseArrExn: makeBaseArrExn,
  makeBaseArr: makeBaseArr
};

function show$1(num) {
  var showDigits = function (num) {
    return Belt_List.reduce(num, "", (function (str, d) {
                  return str + show(d);
                }));
  };
  var variant = num.NAME;
  if (variant === "Binary") {
    return "base 2: " + showDigits(num.VAL);
  } else if (variant === "Decimal") {
    return "base 10: " + showDigits(num.VAL);
  } else {
    return "base 16: " + showDigits(num.VAL);
  }
}

function make(d_lst, base) {
  if (base !== 2) {
    if (base !== 10) {
      if (base !== 16) {
        return ;
      } else {
        return Belt_Option.map(makeBaseList(d_lst, makeHexadecimal), (function (num) {
                      return {
                              NAME: "Hexadecimal",
                              VAL: num
                            };
                    }));
      }
    } else {
      return Belt_Option.map(makeBaseList(d_lst, makeDecimal), (function (num) {
                    return {
                            NAME: "Decimal",
                            VAL: num
                          };
                  }));
    }
  } else {
    return Belt_Option.map(makeBaseList(d_lst, makeBinary), (function (num) {
                  return {
                          NAME: "Binary",
                          VAL: num
                        };
                }));
  }
}

function fromStrWithRadix(radix, n_str) {
  var str_arr = n_str.split("");
  var d_arr = Belt_Array.keepMap(str_arr, fromStr);
  if (d_arr.length === str_arr.length) {
    return make(Belt_List.fromArray(d_arr), radix);
  }
  
}

function pred$1(num) {
  if (typeof num !== "object") {
    return ;
  }
  if (num.NAME !== "Binary") {
    return ;
  }
  var max_d = Belt_Option.getExn(Belt_Set.maximum(binarySet));
  var aux = function (_ds, _ds_pred) {
    while(true) {
      var ds_pred = _ds_pred;
      var ds = _ds;
      if (!ds) {
        return /* [] */0;
      }
      var d = ds.hd;
      if (d === 0) {
        _ds_pred = Belt_List.add(ds_pred, max_d);
        _ds = ds.tl;
        continue ;
      }
      var d_ = pred(d);
      if (d_ !== undefined) {
        return Belt_List.reverseConcat(ds.tl, Belt_List.add(ds_pred, d_));
      }
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    };
  };
  return aux(Belt_List.reverse(num.VAL), /* [] */0);
}

var $$Number = {
  show: show$1,
  make: make,
  fromStrWithRadix: fromStrWithRadix,
  pred: pred$1
};

export {
  Digit ,
  $$Number ,
  
}
/* CmpDigit Not a pure module */
