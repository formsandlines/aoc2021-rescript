// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Fs from "fs";
import * as Curry from "../node_modules/rescript/lib/es6/curry.js";
import * as Js_int from "../node_modules/rescript/lib/es6/js_int.js";
import * as Belt_Id from "../node_modules/rescript/lib/es6/belt_Id.js";
import * as Belt_Int from "../node_modules/rescript/lib/es6/belt_Int.js";
import * as Caml_obj from "../node_modules/rescript/lib/es6/caml_obj.js";
import * as Belt_List from "../node_modules/rescript/lib/es6/belt_List.js";
import * as Belt_Array from "../node_modules/rescript/lib/es6/belt_Array.js";
import * as Caml_int32 from "../node_modules/rescript/lib/es6/caml_int32.js";
import * as Belt_Option from "../node_modules/rescript/lib/es6/belt_Option.js";
import * as Belt_SetString from "../node_modules/rescript/lib/es6/belt_SetString.js";

function filterEmptyStr(strArr) {
  return Belt_Array.keep(strArr, (function (str) {
                return str !== "";
              }));
}

function toIntArrExn(strArr) {
  return Belt_Array.map(strArr, (function (nStr) {
                return Belt_Option.getExn(Belt_Int.fromString(nStr));
              }));
}

function flatMap(arr, fn) {
  return Belt_Array.reduce(arr, [], (function (acc, x) {
                return Belt_Array.concat(acc, Curry._1(fn, x));
              }));
}

function cartesProd(arr, dim) {
  var aux = function (arr, seq, n) {
    if (n > 0) {
      return flatMap(arr, (function (x) {
                    return aux(arr, Belt_Array.concat(seq, [x]), n - 1 | 0);
                  }));
    } else {
      return [seq];
    }
  };
  return aux(arr, [], dim);
}

var ArrayExt = {
  filterEmptyStr: filterEmptyStr,
  toIntArrExn: toIntArrExn,
  flatMap: flatMap,
  cartesProd: cartesProd
};

function hasDecimal(x) {
  return (x | 0) < x;
}

var FloatExt = {
  hasDecimal: hasDecimal
};

function padToXn(toEndOpt, padStrOpt, str, n) {
  var toEnd = toEndOpt !== undefined ? toEndOpt : false;
  var padStr = padStrOpt !== undefined ? padStrOpt : "0";
  var diff = n - Caml_int32.mod_(str.length, n) | 0;
  if (diff < n) {
    if (toEnd) {
      return str + padStr.repeat(diff);
    } else {
      return padStr.repeat(diff) + str;
    }
  } else {
    return str;
  }
}

var StringExt = {
  padToXn: padToXn
};

var CmpStr = Belt_Id.MakeComparable({
      cmp: Belt_SetString.cmp
    });

var SetExt = {
  CmpStr: CmpStr
};

function hexToBin(padOpt, hexStr) {
  var pad = padOpt !== undefined ? padOpt : false;
  var n = Number("0x" + hexStr);
  if (Number.isNaN(n)) {
    return ;
  }
  var binStr = n.toString(2);
  return pad ? padToXn(undefined, undefined, binStr, 4) : binStr;
}

var NumSys = {
  hexToBin: hexToBin
};

function read(path) {
  return Fs.readFileSync(path, "utf8");
}

function toLines(str) {
  return filterEmptyStr(str.split("\n"));
}

var Input = {
  read: read,
  toLines: toLines
};

function has(elem, param) {
  if (Caml_obj.caml_equal(param[0], elem)) {
    return true;
  } else {
    return Caml_obj.caml_equal(param[1], elem);
  }
}

function hasNot(elem, param) {
  if (Caml_obj.caml_notequal(param[0], elem)) {
    return Caml_obj.caml_notequal(param[1], elem);
  } else {
    return false;
  }
}

function fst(param) {
  return param[0];
}

function snd(param) {
  return param[1];
}

function get(param, i) {
  if (i <= 0) {
    return param[0];
  } else {
    return param[1];
  }
}

function reduce(pair, init, reducerFn) {
  var aux = function (acc, pair, i) {
    return Curry._4(reducerFn, get(pair, i), acc, pair, i);
  };
  return aux(aux(init, pair, 0), pair, 1);
}

function cmp(param, param$1) {
  var c = Caml_obj.caml_compare(param[0], param$1[0]);
  if (c !== 0) {
    return c;
  } else {
    return Caml_obj.caml_compare(param[1], param$1[1]);
  }
}

var CmpInt = Belt_Id.MakeComparable({
      cmp: cmp
    });

function cmp$1(param, param$1) {
  var c = Caml_obj.caml_compare(param[0], param$1[0]);
  if (c !== 0) {
    return c;
  } else {
    return Caml_obj.caml_compare(param[1], param$1[1]);
  }
}

var CmpStr$1 = Belt_Id.MakeComparable({
      cmp: cmp$1
    });

function getArrBounds(minFromOpt, maxFromOpt, tp) {
  var minFrom = minFromOpt !== undefined ? minFromOpt : Js_int.max;
  var maxFrom = maxFromOpt !== undefined ? maxFromOpt : 0;
  return Belt_Array.reduce(tp, [
              minFrom,
              maxFrom
            ], (function (param, n) {
                var max = param[1];
                var min = param[0];
                return [
                        n < min ? n : min,
                        n > max ? n : max
                      ];
              }));
}

var Tuple = {
  has: has,
  hasNot: hasNot,
  fst: fst,
  snd: snd,
  get: get,
  reduce: reduce,
  CmpInt: CmpInt,
  CmpStr: CmpStr$1,
  getArrBounds: getArrBounds
};

function show(tree, showFn) {
  var aux = function (param, d, i) {
    var idx = String(d) + "-" + String(i);
    return "\n" + ("  ".repeat(d) + idx) + ": " + Curry._1(showFn, param._0) + Belt_Array.reduceWithIndex(param._1, "", (function (acc, subtree, j) {
                  return acc + aux(subtree, d + 1 | 0, j);
                }));
  };
  return aux(tree, 0, 0);
}

function findPaths(tree, endNode) {
  var aux = function (tree, index) {
    var subtrees = tree._1;
    if (subtrees.length !== 0) {
      return Belt_Array.reduceWithIndex(subtrees, [], (function (acc, subtree, i) {
                    return Belt_Array.concat(acc, aux(subtree, Belt_List.add(index, i)));
                  }));
    } else if (Caml_obj.caml_equal(tree._0, endNode)) {
      return [index];
    } else {
      return [];
    }
  };
  return aux(tree, {
              hd: 0,
              tl: /* [] */0
            });
}

function getPathFromIndex(indexList, tree) {
  var aux = function (indexList, tree) {
    var subtrees = tree._1;
    var node = tree._0;
    if (subtrees.length === 0) {
      return {
              hd: node,
              tl: /* [] */0
            };
    }
    if (!indexList) {
      return /* [] */0;
    }
    var subtree = Belt_Array.get(subtrees, indexList.hd);
    if (subtree !== undefined) {
      return {
              hd: node,
              tl: aux(indexList.tl, subtree)
            };
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
  return aux(Belt_List.tailExn(indexList), tree);
}

var ArrayTree = {
  show: show,
  findPaths: findPaths,
  getPathFromIndex: getPathFromIndex
};

var cmp$2 = (function(a,b) {
    if (a < b) { return -1; }
    else if (a > b) { return 1; }
    else { return 0; }
  });

var add = (function(x,y) { return x + y; });

function addInt(t, i) {
  return add(t, BigInt(i));
}

var mul = (function(x,y) { return x * y; });

function mulInt(t, i) {
  return mul(t, BigInt(i));
}

var eq = (function(x,y) { return x == y; });

var gr = (function(x,y) { return x > y; });

var sm = (function(x,y) { return x < y; });

var grEq = (function(x,y) { return x >= y; });

var smEq = (function(x,y) { return x <= y; });

var zero = 0n;

var one = 1n;

var $$BigInt$1 = {
  cmp: cmp$2,
  add: add,
  addInt: addInt,
  mul: mul,
  mulInt: mulInt,
  eq: eq,
  gr: gr,
  sm: sm,
  grEq: grEq,
  smEq: smEq,
  zero: zero,
  one: one
};

export {
  ArrayExt ,
  FloatExt ,
  StringExt ,
  SetExt ,
  NumSys ,
  Input ,
  Tuple ,
  ArrayTree ,
  $$BigInt$1 as $$BigInt,
  
}
/* CmpStr Not a pure module */
