// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Fs from "fs";
import * as Belt_Id from "../node_modules/rescript/lib/es6/belt_Id.js";
import * as Belt_Int from "../node_modules/rescript/lib/es6/belt_Int.js";
import * as Caml_obj from "../node_modules/rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "../node_modules/rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "../node_modules/rescript/lib/es6/belt_Option.js";

function filterEmptyStr(strArr) {
  return Belt_Array.keep(strArr, (function (str) {
                return str !== "";
              }));
}

function toIntArrExn(strArr) {
  return Belt_Array.map(strArr, (function (nStr) {
                return Belt_Option.getExn(Belt_Int.fromString(nStr));
              }));
}

var ArrayExt = {
  filterEmptyStr: filterEmptyStr,
  toIntArrExn: toIntArrExn
};

function read(path) {
  return Fs.readFileSync(path, "utf8");
}

function toLines(str) {
  return filterEmptyStr(str.split("\n"));
}

var Input = {
  read: read,
  toLines: toLines
};

function has(elem, param) {
  if (Caml_obj.caml_equal(param[0], elem)) {
    return true;
  } else {
    return Caml_obj.caml_equal(param[1], elem);
  }
}

function hasNot(elem, param) {
  if (Caml_obj.caml_notequal(param[0], elem)) {
    return Caml_obj.caml_notequal(param[1], elem);
  } else {
    return false;
  }
}

function cmp(param, param$1) {
  var c = Caml_obj.caml_compare(param[0], param$1[0]);
  if (c !== 0) {
    return c;
  } else {
    return Caml_obj.caml_compare(param[1], param$1[1]);
  }
}

var CmpInt = Belt_Id.MakeComparable({
      cmp: cmp
    });

function cmp$1(param, param$1) {
  var c = Caml_obj.caml_compare(param[0], param$1[0]);
  if (c !== 0) {
    return c;
  } else {
    return Caml_obj.caml_compare(param[1], param$1[1]);
  }
}

var CmpStr = Belt_Id.MakeComparable({
      cmp: cmp$1
    });

var Tuple = {
  has: has,
  hasNot: hasNot,
  CmpInt: CmpInt,
  CmpStr: CmpStr
};

function show(tree) {
  var aux = function (tree, d, i) {
    if (tree.TAG !== /* Leaf */0) {
      return "\n" + "  ".repeat(d) + "[ " + Belt_Array.reduceWithIndex(tree._0, "", (function (acc, subtree, j) {
                    var curr = aux(subtree, d + 1 | 0, j);
                    var sep = j > 0 ? ", " : "";
                    var sep$1 = acc.endsWith("]") ? sep + (
                        curr.endsWith("]") ? "" : "\n"
                      ) + "  ".repeat(d + 1 | 0) : sep;
                    return acc + sep$1 + curr;
                  })) + " ]";
    }
    var idx = "<" + String(d) + "," + String(i) + ">";
    return tree._0 + " " + idx;
  };
  return aux(tree, 0, 0);
}

var Tree = {
  show: show
};

var cmp$2 = (function(a,b) {
    if (a < b) { return -1; }
    else if (a > b) { return 1; }
    else { return 0; }
  });

var add = (function(x,y) { return x + y; });

function addInt(t, i) {
  return add(t, BigInt(i));
}

var mul = (function(x,y) { return x * y; });

function mulInt(t, i) {
  return mul(t, BigInt(i));
}

var eq = (function(x,y) { return x == y; });

var gr = (function(x,y) { return x > y; });

var sm = (function(x,y) { return x < y; });

var grEq = (function(x,y) { return x >= y; });

var smEq = (function(x,y) { return x <= y; });

var zero = 0n;

var one = 1n;

var $$BigInt$1 = {
  cmp: cmp$2,
  add: add,
  addInt: addInt,
  mul: mul,
  mulInt: mulInt,
  eq: eq,
  gr: gr,
  sm: sm,
  grEq: grEq,
  smEq: smEq,
  zero: zero,
  one: one
};

export {
  ArrayExt ,
  Input ,
  Tuple ,
  Tree ,
  $$BigInt$1 as $$BigInt,
  
}
/* CmpInt Not a pure module */
