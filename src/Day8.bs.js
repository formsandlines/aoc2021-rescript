// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Helper from "./Helper.bs.js";
import * as Belt_Int from "../node_modules/rescript/lib/es6/belt_Int.js";
import * as Belt_Map from "../node_modules/rescript/lib/es6/belt_Map.js";
import * as Belt_Array from "../node_modules/rescript/lib/es6/belt_Array.js";
import * as Belt_MapInt from "../node_modules/rescript/lib/es6/belt_MapInt.js";
import * as Belt_Option from "../node_modules/rescript/lib/es6/belt_Option.js";
import * as Belt_SetString from "../node_modules/rescript/lib/es6/belt_SetString.js";

function identify(context, compDigit, compSize) {
  var match = Belt_Array.partition(context, (function (set) {
          return Belt_SetString.size(Belt_SetString.intersect(compDigit, set)) === compSize;
        }));
  return [
          Belt_Array.getExn(match[0], 0),
          match[1]
        ];
}

function decodeDigits(encrDigitSets, uniqueSegmDigits) {
  var digits = Belt_MapInt.fromArray(Belt_Array.map(Belt_MapInt.toArray(uniqueSegmDigits), (function (param) {
              var segmCount = param[0];
              return [
                      param[1],
                      Belt_Array.getExn(Belt_Array.keep(encrDigitSets, (function (set) {
                                  return Belt_SetString.size(set) === segmCount;
                                })), 0)
                    ];
            })));
  var d1 = Belt_MapInt.getExn(digits, 1);
  var d4 = Belt_MapInt.getExn(digits, 4);
  var d7 = Belt_MapInt.getExn(digits, 7);
  var d8 = Belt_MapInt.getExn(digits, 8);
  var seg5s = Belt_Array.keep(encrDigitSets, (function (set) {
          return Belt_SetString.size(set) === 5;
        }));
  var seg6s = Belt_Array.keep(encrDigitSets, (function (set) {
          return Belt_SetString.size(set) === 6;
        }));
  var match = identify(seg5s, d1, 2);
  var d3 = match[0];
  var match$1 = identify(seg6s, d3, 5);
  var d9 = match$1[0];
  var match$2 = identify(match[1], d9, 5);
  var d2 = Belt_Array.getExn(match$2[1], 0);
  var match$3 = identify(match$1[1], d7, 2);
  var d0 = Belt_Array.getExn(match$3[1], 0);
  return Belt_Map.fromArray([
              [
                d0,
                0
              ],
              [
                d1,
                1
              ],
              [
                d2,
                2
              ],
              [
                d3,
                3
              ],
              [
                d4,
                4
              ],
              [
                match$2[0],
                5
              ],
              [
                match$3[0],
                6
              ],
              [
                d7,
                7
              ],
              [
                d8,
                8
              ],
              [
                d9,
                9
              ]
            ], Helper.SetExt.CmpStr);
}

function part1(input, uniqueSegmDigits) {
  var outputSegmCounts = Belt_Array.concatMany(Belt_Array.map(input, (function (line) {
              if (line.length !== 2) {
                throw {
                      RE_EXN_ID: "Not_found",
                      Error: new Error()
                    };
              }
              var output = line[1];
              return Belt_Array.map(output, (function (str) {
                            return str.length;
                          }));
            })));
  var uniqueCountSum = Belt_Array.reduce(outputSegmCounts, 0, (function (sum, segmCount) {
          return sum + (
                  Belt_MapInt.has(uniqueSegmDigits, segmCount) ? 1 : 0
                ) | 0;
        }));
  console.log("Sum of digits with unique segment count in output:", uniqueCountSum);
  
}

function part2(input, uniqueSegmDigits) {
  var inputSegmentSets = Belt_Array.map(input, (function (line) {
          if (line.length !== 2) {
            throw {
                  RE_EXN_ID: "Not_found",
                  Error: new Error()
                };
          }
          var encryptedDigits = line[0];
          return Belt_Array.map(encryptedDigits, (function (encrStr) {
                        return Belt_SetString.fromArray(encrStr.split(""));
                      }));
        }));
  var digitMaps = Belt_Array.map(inputSegmentSets, (function (segmSetArr) {
          return decodeDigits(segmSetArr, uniqueSegmDigits);
        }));
  var displays = Belt_Array.zipBy(digitMaps, input, (function (digitMap, line) {
          if (line.length !== 2) {
            throw {
                  RE_EXN_ID: "Not_found",
                  Error: new Error()
                };
          }
          var output = line[1];
          return Belt_Array.map(output, (function (encrStr) {
                          var encrSet = Belt_SetString.fromArray(encrStr.split(""));
                          var n = Belt_Map.get(digitMap, encrSet);
                          if (n !== undefined) {
                            return String(n);
                          } else {
                            return "_";
                          }
                        })).join("");
        }));
  var outputVals = Belt_Array.map(displays, (function (nStr) {
          return Belt_Option.getWithDefault(Belt_Int.fromString(nStr), -99999);
        }));
  console.log("Output numbers:", displays);
  console.log("Output values:", Belt_Array.reduce(outputVals, 0, (function (prim0, prim1) {
              return prim0 + prim1 | 0;
            })));
  
}

var data = Helper.Input.read("./src/data/input_day8.txt");

function processInput(input) {
  return Belt_Array.map(Helper.Input.toLines(input), (function (line) {
                return Belt_Array.map(line.split("|"), (function (str) {
                              return Helper.ArrayExt.filterEmptyStr(str.split(" "));
                            }));
              }));
}

var input = processInput(data);

var uniqueSegmDigits = Belt_MapInt.fromArray([
      [
        2,
        1
      ],
      [
        3,
        7
      ],
      [
        4,
        4
      ],
      [
        7,
        8
      ]
    ]);

var equalSegmDigits = Belt_MapInt.fromArray([
      [
        5,
        [
          2,
          3,
          5
        ]
      ],
      [
        6,
        [
          0,
          6,
          9
        ]
      ]
    ]);

part1(input, uniqueSegmDigits);

part2(input, uniqueSegmDigits);

var ex1 = "be cfbegad cbdgef fgaecd cgeb fdcge agebfd fecdb fabcd edb | fdgacbe cefdb cefbgd gcbe\nedbfga begcd cbg gc gcadebf fbgde acbgfd abcde gfcbed gfec | fcgedb cgb dgebacf gc\nfgaebd cg bdaec gdafb agbcfd gdcbef bgcad gfac gcb cdgabef | cg cg fdcagb cbg\nfbegcd cbd adcefb dageb afcb bc aefdc ecdab fgdeca fcdbega | efabcd cedba gadfec cb\naecbfdg fbg gf bafeg dbefa fcge gcbea fcaegb dgceab fcbdga | gecf egdcabf bgf bfgea\nfgeab ca afcebg bdacfeg cfaedg gcfdb baec bfadeg bafgc acf | gebdcfa ecba ca fadegcb\ndbcfg fgd bdegcaf fgec aegbdf ecdfab fbedc dacgb gdcebf gf | cefg dcbef fcge gbcadfe\nbdfegc cbegaf gecbf dfcage bdacg ed bedf ced adcbefg gebcd | ed bcgafe cdgba cbgef\negadfb cdbfeg cegd fecab cgb gbdefca cg fgcdab egfdb bfceg | gbdfcae bgc cg cgb\ngcafb gcf dcaebfg ecagb gf abcdeg gaef cafbge fdbac fegbdc | fgae cfgab fg bagce";

var ex2 = "acedgfb cdfbe gcdfa fbcad dab cefabd cdfgeb eafb cagedb ab | cdfeb fcadb cdfeb cdbaf";

export {
  identify ,
  decodeDigits ,
  part1 ,
  part2 ,
  data ,
  ex1 ,
  ex2 ,
  processInput ,
  input ,
  uniqueSegmDigits ,
  equalSegmDigits ,
  
}
/* data Not a pure module */
