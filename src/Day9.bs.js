// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Helper from "./Helper.bs.js";
import * as Belt_Set from "../node_modules/rescript/lib/es6/belt_Set.js";
import * as Caml_obj from "../node_modules/rescript/lib/es6/caml_obj.js";
import * as Belt_List from "../node_modules/rescript/lib/es6/belt_List.js";
import * as Belt_Array from "../node_modules/rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "../node_modules/rescript/lib/es6/belt_Option.js";
import * as Belt_SortArrayInt from "../node_modules/rescript/lib/es6/belt_SortArrayInt.js";

function collectLowPoints(heightmap) {
  return Belt_Array.reduceWithIndex(heightmap, /* [] */0, (function (lows, heightRow, y) {
                return Belt_List.concat(lows, Belt_Array.reduceWithIndex(heightRow, /* [] */0, (function (lowsRow, height, x) {
                                  var neighbours = Belt_Array.map(Belt_Array.keep([
                                            Belt_Array.get(heightRow, x - 1 | 0),
                                            Belt_Array.get(heightRow, x + 1 | 0),
                                            Belt_Option.flatMap(Belt_Array.get(heightmap, y - 1 | 0), (function (arr) {
                                                    return Belt_Array.get(arr, x);
                                                  })),
                                            Belt_Option.flatMap(Belt_Array.get(heightmap, y + 1 | 0), (function (arr) {
                                                    return Belt_Array.get(arr, x);
                                                  }))
                                          ], (function (opt) {
                                              return opt !== undefined;
                                            })), Belt_Option.getExn);
                                  if (Belt_Array.every(neighbours, (function (nbHeight) {
                                            return Caml_obj.caml_lessthan(height, nbHeight);
                                          }))) {
                                    return Belt_List.add(lowsRow, height);
                                  } else {
                                    return lowsRow;
                                  }
                                })));
              }));
}

function getAdjacentCoords(param, heightmap, param$1) {
  var maxY = param$1[1];
  var maxX = param$1[0];
  var y = param[1];
  var x = param[0];
  return Belt_Set.keep(Belt_Set.fromArray([
                  [
                    x - 1 | 0,
                    y
                  ],
                  [
                    x + 1 | 0,
                    y
                  ],
                  [
                    x,
                    y - 1 | 0
                  ],
                  [
                    x,
                    y + 1 | 0
                  ]
                ], Helper.Tuple.CmpInt), (function (param) {
                var sy = param[1];
                var sx = param[0];
                var inBounds = sx >= 0 && sx <= maxX && sy >= 0 && sy <= maxY;
                if (inBounds) {
                  return Belt_Array.getExn(Belt_Array.getExn(heightmap, sy), sx) !== 9;
                } else {
                  return false;
                }
              }));
}

function updateBasins(basins, coords) {
  var _basins = basins;
  var _basins$p = /* [] */0;
  while(true) {
    var basins$p = _basins$p;
    var basins$1 = _basins;
    if (!basins$1) {
      return [
              basins$p,
              false
            ];
    }
    var r = basins$1.tl;
    var basin = basins$1.hd;
    if (!Belt_Set.isEmpty(Belt_Set.intersect(coords, basin))) {
      return [
              Belt_List.concat(basins$p, {
                    hd: Belt_Set.union(basin, coords),
                    tl: r
                  }),
              true
            ];
    }
    _basins$p = Belt_List.add(basins$p, basin);
    _basins = r;
    continue ;
  };
}

function mergeBasins(basins) {
  if (!basins) {
    return /* [] */0;
  }
  var r = basins.tl;
  var basin = basins.hd;
  var match = updateBasins(r, basin);
  if (match[1]) {
    return match[0];
  } else {
    return {
            hd: basin,
            tl: mergeBasins(r)
          };
  }
}

function collectBasins(heightmap) {
  var maxX = Belt_Array.getExn(heightmap, 0).length - 1 | 0;
  var maxY = heightmap.length - 1 | 0;
  var allAdjCoords = Belt_Array.reduceWithIndex(heightmap, [], (function (adjCoords, heightRow, y) {
          return Belt_Array.concat(adjCoords, Belt_Array.keep(Belt_Array.mapWithIndex(heightRow, (function (x, height) {
                                if (height !== 9) {
                                  return Belt_Set.add(getAdjacentCoords([
                                                  x,
                                                  y
                                                ], heightmap, [
                                                  maxX,
                                                  maxY
                                                ]), [
                                              x,
                                              y
                                            ]);
                                } else {
                                  return Belt_Set.make(Helper.Tuple.CmpInt);
                                }
                              })), (function (s) {
                            return Belt_Set.size(s) > 0;
                          })));
        }));
  return Belt_Array.reduce(allAdjCoords, /* [] */0, (function (basins, coords) {
                var match = updateBasins(basins, coords);
                var basins$1 = match[0];
                if (match[1]) {
                  return mergeBasins(basins$1);
                } else {
                  return Belt_List.add(basins$1, coords);
                }
              }));
}

function renderBasins(heightmap, basins) {
  var basinmap = Belt_Array.mapWithIndex(heightmap, (function (y, heights) {
            return Belt_Array.mapWithIndex(heights, (function (x, param) {
                            var idxs = Belt_List.reduceWithIndex(basins, /* [] */0, (function (idxs, basin, i) {
                                    if (Belt_Set.has(basin, [
                                            x,
                                            y
                                          ])) {
                                      return Belt_List.add(idxs, i);
                                    } else {
                                      return idxs;
                                    }
                                  }));
                            if (idxs) {
                              if (idxs.tl) {
                                return "X";
                              } else {
                                return String.fromCharCode(idxs.hd + 10241 | 0);
                              }
                            } else {
                              return " ";
                            }
                          })).join("");
          })).join("\n");
  console.log(basinmap);
  
}

function part1(heightmap) {
  var lowPoints = collectLowPoints(heightmap);
  var riskLevels = Belt_List.toArray(Belt_List.map(lowPoints, (function (param) {
              return 1 + param | 0;
            })));
  var result = Belt_Array.reduce(riskLevels, 0, (function (prim0, prim1) {
          return prim0 + prim1 | 0;
        }));
  console.log("Risk levels:", riskLevels);
  console.log("Result:", result);
  
}

function part2(heightmap) {
  var basins = collectBasins(heightmap);
  var basinSizes = Belt_SortArrayInt.stableSort(Belt_Array.map(Belt_List.toArray(basins), Belt_Set.size));
  var largest3 = Belt_Array.sliceToEnd(basinSizes, -3);
  console.log("Size of largest 3 basins:", largest3);
  var result = Belt_Array.reduce(largest3, 1, (function (prim0, prim1) {
          return Math.imul(prim0, prim1);
        }));
  console.log("Result:", result);
  
}

var data = Helper.Input.read("./src/data/input_day9.txt");

function processInput(input) {
  return Belt_Array.map(Helper.Input.toLines(input), (function (line) {
                return Helper.ArrayExt.toIntArrExn(Helper.ArrayExt.filterEmptyStr(line.trim().split("")));
              }));
}

var input = processInput(data);

part1(input);

part2(input);

var ex1 = "\n2199943210\n3987894921\n9856789892\n8767896789\n9899965678";

var ex2 = "\n1293\n0920\n9191\n9012";

export {
  collectLowPoints ,
  getAdjacentCoords ,
  updateBasins ,
  mergeBasins ,
  collectBasins ,
  renderBasins ,
  part1 ,
  part2 ,
  data ,
  ex1 ,
  ex2 ,
  processInput ,
  input ,
  
}
/* data Not a pure module */
